type AnyoneCallableUpdated @entity {
  id: ID!
  status: Boolean! # bool
}

type CallerStatusUpdated @entity {
  id: ID!
  caller: Bytes! # address
  status: Boolean! # bool
}

type Transaction @entity {
  id: ID!
  from: Bytes
  to: Bytes
  timestamp: BigInt!
  gasLimit: BigInt
  gasPriceInGwei: BigInt
}

type Transfer @entity {
  id: ID!
  txnHash: Bytes!
  from: Bytes
  to: Bytes
  value: BigInt!
  setToken: SetToken!
  timestamp: BigInt!
}

type FeeRecipientUpdated @entity {
  id: ID!
  setToken: Bytes! # address
  newFeeRecipient: Bytes! # address
}

type IssueFeeUpdated @entity {
  id: ID!
  setToken: Bytes! # address
  newIssueFee: BigInt! # uint256
}

type RedeemFeeUpdated @entity {
  id: ID!
  setToken: Bytes! # address
  newRedeemFee: BigInt! # uint256
}

# Might be unneccesary to grab
# Issuer is the person the token is being issued to.
type Issuer @entity {
  id: ID!
  address: Bytes!
  setTokensIssued: [TokenIssuance!]!
}

type TokenIssuance @entity {
  id: ID!
  # buyerAddress is the Issuer
  buyerAddress: Bytes!
  setToken: SetToken!
  quantity: BigInt!
  issuer: Issuer!
  transaction: Transaction!
  fee: Fee!
}

type Component @entity {
  id: ID!
  address: Bytes!
  positionValue: BigInt!
}

# SetTokenCreator is the contract where we should be populating this entity (or being populating)
type SetToken @entity {
  id: ID!
  address: Bytes!
  name: String!
  manager: Manager!
  # fees: [Fee!]! 
  issuances: [TokenIssuance!]! @derivedFrom(field: "setToken")
  totalSupply: BigInt!
  rebalances: [Rebalance!]! @derivedFrom(field: "setToken")
  redemptions: [TokenRedemption!]! @derivedFrom(field: "setToken")
  components: [Component!]! 
}

type Fee @entity {
  id: ID!
  timestamp: BigInt!
  manager: Manager!
  managerPayout: BigInt
  protocolPayout: BigInt
  transaction: Transaction!
}

type RebalanceDetails @entity {
  id: ID!
  currentLeverageRatio: BigInt! # uint256
  newLeverageRatio: BigInt! # uint256
  chunkRebalanceNotional: BigInt! # uint256
  totalRebalanceNotional: BigInt! # uint256
}

type Rebalance @entity {
  id: ID!
  setToken: SetToken! @derivedFrom(field: "rebalances")
  rebalanceDetails: RebalanceDetails!
  transaction: Transaction!
  transactionHash: Bytes!
}

type Manager @entity {
  id: ID!
  address: Bytes!
  feeAccrualHistory: [Fee!]! @derivedFrom(field: "manager")
  totalFees: BigInt
  setToken: SetToken!
}

type TokenRedemption @entity {
  id: ID!
  setToken: SetToken!
  redeemer: Bytes!
  transaction: Transaction!
  quantity: BigInt!
  fee: Fee!
}
type SetTokenRedeemed @entity {
  id: ID!
  setToken: Bytes! # address
  redeemer: Bytes! # address
  to: Bytes! # address
  transaction: Transaction!
  managerFee: BigInt! # uint256
  protocolFee: BigInt! # uint256
}

type Disengaged @entity {
  id: ID!
  timestamp: BigInt!
  currentLeverageRatio: BigInt! # uint256
  newLeverageRatio: BigInt! # uint25
  chunkRebalanceNotional: BigInt! # uint256
  totalRebalanceNotional: BigInt! # uint256
}

type Engaged @entity {
  id: ID!
  timestamp: BigInt!
  currentLeverageRatio: BigInt! # uint256
  newLeverageRatio: BigInt! # uint256
  chunkRebalanceNotional: BigInt! # uint256
  totalRebalanceNotional: BigInt! # uint256
}

type ExchangeAdded @entity {
  id: ID!
  exchangeName: String! # string
  twapMaxTradeSize: BigInt! # uint256
  exchangeLastTradeTimestamp: BigInt! # uint256
  incentivizedTwapMaxTradeSize: BigInt! # uint256
  leverExchangeData: Bytes! # bytes
  deleverExchangeData: Bytes! # bytes
}

type ExchangeRemoved @entity {
  id: ID!
  exchangeName: String! # string
}

type ExchangeUpdated @entity {
  id: ID!
  exchangeName: String! # string
  twapMaxTradeSize: BigInt! # uint256
  exchangeLastTradeTimestamp: BigInt! # uint256
  incentivizedTwapMaxTradeSize: BigInt! # uint256
  leverExchangeData: Bytes! # bytes
  deleverExchangeData: Bytes! # bytes
}

type ExecutionSettingsUpdated @entity {
  id: ID!
  unutilizedLeveragePercentage: BigInt! # uint256
  twapMaxTradeSize: BigInt! # uint256
  twapCooldownPeriod: BigInt! # uint256
  slippageTolerance: BigInt! # uint256
  exchangeName: String! # string
  exchangeData: Bytes! # bytes
}

type IncentiveSettingsUpdated @entity {
  id: ID!
  etherReward: BigInt! # uint256
  incentivizedLeverageRatio: BigInt! # uint256
  incentivizedSlippageTolerance: BigInt! # uint256
  incentivizedTwapCooldownPeriod: BigInt! # uint256
  incentivizedTwapMaxTradeSize: BigInt! # uint256
}

type MethodologySettingsUpdated @entity {
  id: ID!
  targetLeverageRatio: BigInt! # uint256
  minLeverageRatio: BigInt! # uint25
  maxLeverageRatio: BigInt! # uint256
  recenteringSpeed: BigInt! # uint256
  rebalanceInterval: BigInt! # uint256
}


type RipcordCalled @entity {
  id: ID!
  timestamp: BigInt!
  currentLeverageRatio: BigInt! # uint256
  newLeverageRatio: BigInt! # uint256
  rebalanceNotional: BigInt! # uint256
  etherIncentive: BigInt! # uint256
}

type StreamingFee @entity {
  id: ID!
  timestamp: BigInt!
  setToken: Bytes! # address indexed
  managerFee: BigInt # uint256
  protocolFee: BigInt # uint256
  newStreamingFee: BigInt # uint256
  newFeeRecipient: Bytes # address
}
