// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Bytes,
  BigInt,
  BigDecimal
} from "@graphprotocol/graph-ts";

export class Transaction extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("timestamp", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Transaction entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save Transaction entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("Transaction", id.toString(), this);
    }
  }

  static load(id: string): Transaction | null {
    return changetype<Transaction | null>(store.get("Transaction", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get from(): Bytes | null {
    let value = this.get("from");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set from(value: Bytes | null) {
    if (!value) {
      this.unset("from");
    } else {
      this.set("from", Value.fromBytes(<Bytes>value));
    }
  }

  get to(): Bytes | null {
    let value = this.get("to");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set to(value: Bytes | null) {
    if (!value) {
      this.unset("to");
    } else {
      this.set("to", Value.fromBytes(<Bytes>value));
    }
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get gasLimit(): BigInt | null {
    let value = this.get("gasLimit");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set gasLimit(value: BigInt | null) {
    if (!value) {
      this.unset("gasLimit");
    } else {
      this.set("gasLimit", Value.fromBigInt(<BigInt>value));
    }
  }

  get gasPriceInGwei(): BigInt | null {
    let value = this.get("gasPriceInGwei");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set gasPriceInGwei(value: BigInt | null) {
    if (!value) {
      this.unset("gasPriceInGwei");
    } else {
      this.set("gasPriceInGwei", Value.fromBigInt(<BigInt>value));
    }
  }
}

export class Transfer extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("txnHash", Value.fromBytes(Bytes.empty()));
    this.set("value", Value.fromBigInt(BigInt.zero()));
    this.set("setToken", Value.fromString(""));
    this.set("timestamp", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Transfer entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save Transfer entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("Transfer", id.toString(), this);
    }
  }

  static load(id: string): Transfer | null {
    return changetype<Transfer | null>(store.get("Transfer", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get txnHash(): Bytes {
    let value = this.get("txnHash");
    return value!.toBytes();
  }

  set txnHash(value: Bytes) {
    this.set("txnHash", Value.fromBytes(value));
  }

  get from(): Bytes | null {
    let value = this.get("from");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set from(value: Bytes | null) {
    if (!value) {
      this.unset("from");
    } else {
      this.set("from", Value.fromBytes(<Bytes>value));
    }
  }

  get to(): Bytes | null {
    let value = this.get("to");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set to(value: Bytes | null) {
    if (!value) {
      this.unset("to");
    } else {
      this.set("to", Value.fromBytes(<Bytes>value));
    }
  }

  get value(): BigInt {
    let value = this.get("value");
    return value!.toBigInt();
  }

  set value(value: BigInt) {
    this.set("value", Value.fromBigInt(value));
  }

  get setToken(): string {
    let value = this.get("setToken");
    return value!.toString();
  }

  set setToken(value: string) {
    this.set("setToken", Value.fromString(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }
}

export class FeeRecipientUpdated extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("setToken", Value.fromBytes(Bytes.empty()));
    this.set("newFeeRecipient", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save FeeRecipientUpdated entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save FeeRecipientUpdated entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("FeeRecipientUpdated", id.toString(), this);
    }
  }

  static load(id: string): FeeRecipientUpdated | null {
    return changetype<FeeRecipientUpdated | null>(
      store.get("FeeRecipientUpdated", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get setToken(): Bytes {
    let value = this.get("setToken");
    return value!.toBytes();
  }

  set setToken(value: Bytes) {
    this.set("setToken", Value.fromBytes(value));
  }

  get newFeeRecipient(): Bytes {
    let value = this.get("newFeeRecipient");
    return value!.toBytes();
  }

  set newFeeRecipient(value: Bytes) {
    this.set("newFeeRecipient", Value.fromBytes(value));
  }
}

export class IssueFeeUpdated extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("setToken", Value.fromBytes(Bytes.empty()));
    this.set("newIssueFee", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save IssueFeeUpdated entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save IssueFeeUpdated entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("IssueFeeUpdated", id.toString(), this);
    }
  }

  static load(id: string): IssueFeeUpdated | null {
    return changetype<IssueFeeUpdated | null>(store.get("IssueFeeUpdated", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get setToken(): Bytes {
    let value = this.get("setToken");
    return value!.toBytes();
  }

  set setToken(value: Bytes) {
    this.set("setToken", Value.fromBytes(value));
  }

  get newIssueFee(): BigInt {
    let value = this.get("newIssueFee");
    return value!.toBigInt();
  }

  set newIssueFee(value: BigInt) {
    this.set("newIssueFee", Value.fromBigInt(value));
  }
}

export class RedeemFeeUpdated extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("setToken", Value.fromBytes(Bytes.empty()));
    this.set("newRedeemFee", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save RedeemFeeUpdated entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save RedeemFeeUpdated entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("RedeemFeeUpdated", id.toString(), this);
    }
  }

  static load(id: string): RedeemFeeUpdated | null {
    return changetype<RedeemFeeUpdated | null>(
      store.get("RedeemFeeUpdated", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get setToken(): Bytes {
    let value = this.get("setToken");
    return value!.toBytes();
  }

  set setToken(value: Bytes) {
    this.set("setToken", Value.fromBytes(value));
  }

  get newRedeemFee(): BigInt {
    let value = this.get("newRedeemFee");
    return value!.toBigInt();
  }

  set newRedeemFee(value: BigInt) {
    this.set("newRedeemFee", Value.fromBigInt(value));
  }
}

export class Issuer extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("address", Value.fromBytes(Bytes.empty()));
    this.set("setTokensIssued", Value.fromStringArray(new Array(0)));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Issuer entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save Issuer entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("Issuer", id.toString(), this);
    }
  }

  static load(id: string): Issuer | null {
    return changetype<Issuer | null>(store.get("Issuer", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get address(): Bytes {
    let value = this.get("address");
    return value!.toBytes();
  }

  set address(value: Bytes) {
    this.set("address", Value.fromBytes(value));
  }

  get setTokensIssued(): Array<string> {
    let value = this.get("setTokensIssued");
    return value!.toStringArray();
  }

  set setTokensIssued(value: Array<string>) {
    this.set("setTokensIssued", Value.fromStringArray(value));
  }
}

export class TokenIssuance extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("buyerAddress", Value.fromBytes(Bytes.empty()));
    this.set("setToken", Value.fromString(""));
    this.set("quantity", Value.fromBigInt(BigInt.zero()));
    this.set("issuer", Value.fromString(""));
    this.set("transaction", Value.fromString(""));
    this.set("fee", Value.fromString(""));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save TokenIssuance entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save TokenIssuance entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("TokenIssuance", id.toString(), this);
    }
  }

  static load(id: string): TokenIssuance | null {
    return changetype<TokenIssuance | null>(store.get("TokenIssuance", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get buyerAddress(): Bytes {
    let value = this.get("buyerAddress");
    return value!.toBytes();
  }

  set buyerAddress(value: Bytes) {
    this.set("buyerAddress", Value.fromBytes(value));
  }

  get setToken(): string {
    let value = this.get("setToken");
    return value!.toString();
  }

  set setToken(value: string) {
    this.set("setToken", Value.fromString(value));
  }

  get quantity(): BigInt {
    let value = this.get("quantity");
    return value!.toBigInt();
  }

  set quantity(value: BigInt) {
    this.set("quantity", Value.fromBigInt(value));
  }

  get issuer(): string {
    let value = this.get("issuer");
    return value!.toString();
  }

  set issuer(value: string) {
    this.set("issuer", Value.fromString(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    return value!.toString();
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }

  get fee(): string {
    let value = this.get("fee");
    return value!.toString();
  }

  set fee(value: string) {
    this.set("fee", Value.fromString(value));
  }
}

export class Component extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("address", Value.fromBytes(Bytes.empty()));
    this.set("positionValue", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Component entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save Component entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("Component", id.toString(), this);
    }
  }

  static load(id: string): Component | null {
    return changetype<Component | null>(store.get("Component", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get address(): Bytes {
    let value = this.get("address");
    return value!.toBytes();
  }

  set address(value: Bytes) {
    this.set("address", Value.fromBytes(value));
  }

  get positionValue(): BigInt {
    let value = this.get("positionValue");
    return value!.toBigInt();
  }

  set positionValue(value: BigInt) {
    this.set("positionValue", Value.fromBigInt(value));
  }
}

export class SetToken extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("address", Value.fromBytes(Bytes.empty()));
    this.set("name", Value.fromString(""));
    this.set("manager", Value.fromString(""));
    this.set("totalSupply", Value.fromBigInt(BigInt.zero()));
    this.set("components", Value.fromStringArray(new Array(0)));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save SetToken entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save SetToken entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("SetToken", id.toString(), this);
    }
  }

  static load(id: string): SetToken | null {
    return changetype<SetToken | null>(store.get("SetToken", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get address(): Bytes {
    let value = this.get("address");
    return value!.toBytes();
  }

  set address(value: Bytes) {
    this.set("address", Value.fromBytes(value));
  }

  get name(): string {
    let value = this.get("name");
    return value!.toString();
  }

  set name(value: string) {
    this.set("name", Value.fromString(value));
  }

  get manager(): string {
    let value = this.get("manager");
    return value!.toString();
  }

  set manager(value: string) {
    this.set("manager", Value.fromString(value));
  }

  get issuances(): Array<string> {
    let value = this.get("issuances");
    return value!.toStringArray();
  }

  set issuances(value: Array<string>) {
    this.set("issuances", Value.fromStringArray(value));
  }

  get totalSupply(): BigInt {
    let value = this.get("totalSupply");
    return value!.toBigInt();
  }

  set totalSupply(value: BigInt) {
    this.set("totalSupply", Value.fromBigInt(value));
  }

  get rebalances(): Array<string> {
    let value = this.get("rebalances");
    return value!.toStringArray();
  }

  set rebalances(value: Array<string>) {
    this.set("rebalances", Value.fromStringArray(value));
  }

  get redemptions(): Array<string> {
    let value = this.get("redemptions");
    return value!.toStringArray();
  }

  set redemptions(value: Array<string>) {
    this.set("redemptions", Value.fromStringArray(value));
  }

  get streamingFee(): Array<string> {
    let value = this.get("streamingFee");
    return value!.toStringArray();
  }

  set streamingFee(value: Array<string>) {
    this.set("streamingFee", Value.fromStringArray(value));
  }

  get components(): Array<string> {
    let value = this.get("components");
    return value!.toStringArray();
  }

  set components(value: Array<string>) {
    this.set("components", Value.fromStringArray(value));
  }
}

export class Fee extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("timestamp", Value.fromBigInt(BigInt.zero()));
    this.set("manager", Value.fromString(""));
    this.set("transaction", Value.fromString(""));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Fee entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save Fee entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("Fee", id.toString(), this);
    }
  }

  static load(id: string): Fee | null {
    return changetype<Fee | null>(store.get("Fee", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get manager(): string {
    let value = this.get("manager");
    return value!.toString();
  }

  set manager(value: string) {
    this.set("manager", Value.fromString(value));
  }

  get managerPayout(): BigInt | null {
    let value = this.get("managerPayout");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set managerPayout(value: BigInt | null) {
    if (!value) {
      this.unset("managerPayout");
    } else {
      this.set("managerPayout", Value.fromBigInt(<BigInt>value));
    }
  }

  get protocolPayout(): BigInt | null {
    let value = this.get("protocolPayout");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set protocolPayout(value: BigInt | null) {
    if (!value) {
      this.unset("protocolPayout");
    } else {
      this.set("protocolPayout", Value.fromBigInt(<BigInt>value));
    }
  }

  get transaction(): string {
    let value = this.get("transaction");
    return value!.toString();
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }
}

export class RebalanceDetails extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("currentLeverageRatio", Value.fromBigInt(BigInt.zero()));
    this.set("newLeverageRatio", Value.fromBigInt(BigInt.zero()));
    this.set("chunkRebalanceNotional", Value.fromBigInt(BigInt.zero()));
    this.set("totalRebalanceNotional", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save RebalanceDetails entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save RebalanceDetails entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("RebalanceDetails", id.toString(), this);
    }
  }

  static load(id: string): RebalanceDetails | null {
    return changetype<RebalanceDetails | null>(
      store.get("RebalanceDetails", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get currentLeverageRatio(): BigInt {
    let value = this.get("currentLeverageRatio");
    return value!.toBigInt();
  }

  set currentLeverageRatio(value: BigInt) {
    this.set("currentLeverageRatio", Value.fromBigInt(value));
  }

  get newLeverageRatio(): BigInt {
    let value = this.get("newLeverageRatio");
    return value!.toBigInt();
  }

  set newLeverageRatio(value: BigInt) {
    this.set("newLeverageRatio", Value.fromBigInt(value));
  }

  get chunkRebalanceNotional(): BigInt {
    let value = this.get("chunkRebalanceNotional");
    return value!.toBigInt();
  }

  set chunkRebalanceNotional(value: BigInt) {
    this.set("chunkRebalanceNotional", Value.fromBigInt(value));
  }

  get totalRebalanceNotional(): BigInt {
    let value = this.get("totalRebalanceNotional");
    return value!.toBigInt();
  }

  set totalRebalanceNotional(value: BigInt) {
    this.set("totalRebalanceNotional", Value.fromBigInt(value));
  }
}

export class Rebalance extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("setToken", Value.fromString(""));
    this.set("rebalanceDetails", Value.fromString(""));
    this.set("transaction", Value.fromString(""));
    this.set("transactionHash", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Rebalance entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save Rebalance entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("Rebalance", id.toString(), this);
    }
  }

  static load(id: string): Rebalance | null {
    return changetype<Rebalance | null>(store.get("Rebalance", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get setToken(): string {
    let value = this.get("setToken");
    return value!.toString();
  }

  set setToken(value: string) {
    this.set("setToken", Value.fromString(value));
  }

  get rebalanceDetails(): string {
    let value = this.get("rebalanceDetails");
    return value!.toString();
  }

  set rebalanceDetails(value: string) {
    this.set("rebalanceDetails", Value.fromString(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    return value!.toString();
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class Manager extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("address", Value.fromBytes(Bytes.empty()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Manager entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save Manager entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("Manager", id.toString(), this);
    }
  }

  static load(id: string): Manager | null {
    return changetype<Manager | null>(store.get("Manager", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get address(): Bytes {
    let value = this.get("address");
    return value!.toBytes();
  }

  set address(value: Bytes) {
    this.set("address", Value.fromBytes(value));
  }

  get feeAccrualHistory(): Array<string> {
    let value = this.get("feeAccrualHistory");
    return value!.toStringArray();
  }

  set feeAccrualHistory(value: Array<string>) {
    this.set("feeAccrualHistory", Value.fromStringArray(value));
  }

  get totalFees(): BigInt | null {
    let value = this.get("totalFees");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set totalFees(value: BigInt | null) {
    if (!value) {
      this.unset("totalFees");
    } else {
      this.set("totalFees", Value.fromBigInt(<BigInt>value));
    }
  }
}

export class TokenRedemption extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("setToken", Value.fromString(""));
    this.set("redeemer", Value.fromBytes(Bytes.empty()));
    this.set("quantity", Value.fromBigInt(BigInt.zero()));
    this.set("fee", Value.fromString(""));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save TokenRedemption entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save TokenRedemption entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("TokenRedemption", id.toString(), this);
    }
  }

  static load(id: string): TokenRedemption | null {
    return changetype<TokenRedemption | null>(store.get("TokenRedemption", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get setToken(): string {
    let value = this.get("setToken");
    return value!.toString();
  }

  set setToken(value: string) {
    this.set("setToken", Value.fromString(value));
  }

  get redeemer(): Bytes {
    let value = this.get("redeemer");
    return value!.toBytes();
  }

  set redeemer(value: Bytes) {
    this.set("redeemer", Value.fromBytes(value));
  }

  get quantity(): BigInt {
    let value = this.get("quantity");
    return value!.toBigInt();
  }

  set quantity(value: BigInt) {
    this.set("quantity", Value.fromBigInt(value));
  }

  get fee(): string {
    let value = this.get("fee");
    return value!.toString();
  }

  set fee(value: string) {
    this.set("fee", Value.fromString(value));
  }
}

export class SetTokenRedeemed extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("setToken", Value.fromBytes(Bytes.empty()));
    this.set("redeemer", Value.fromBytes(Bytes.empty()));
    this.set("to", Value.fromBytes(Bytes.empty()));
    this.set("transaction", Value.fromString(""));
    this.set("managerFee", Value.fromBigInt(BigInt.zero()));
    this.set("protocolFee", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save SetTokenRedeemed entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save SetTokenRedeemed entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("SetTokenRedeemed", id.toString(), this);
    }
  }

  static load(id: string): SetTokenRedeemed | null {
    return changetype<SetTokenRedeemed | null>(
      store.get("SetTokenRedeemed", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get setToken(): Bytes {
    let value = this.get("setToken");
    return value!.toBytes();
  }

  set setToken(value: Bytes) {
    this.set("setToken", Value.fromBytes(value));
  }

  get redeemer(): Bytes {
    let value = this.get("redeemer");
    return value!.toBytes();
  }

  set redeemer(value: Bytes) {
    this.set("redeemer", Value.fromBytes(value));
  }

  get to(): Bytes {
    let value = this.get("to");
    return value!.toBytes();
  }

  set to(value: Bytes) {
    this.set("to", Value.fromBytes(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    return value!.toString();
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }

  get managerFee(): BigInt {
    let value = this.get("managerFee");
    return value!.toBigInt();
  }

  set managerFee(value: BigInt) {
    this.set("managerFee", Value.fromBigInt(value));
  }

  get protocolFee(): BigInt {
    let value = this.get("protocolFee");
    return value!.toBigInt();
  }

  set protocolFee(value: BigInt) {
    this.set("protocolFee", Value.fromBigInt(value));
  }
}

export class RipcordCalled extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("timestamp", Value.fromBigInt(BigInt.zero()));
    this.set("currentLeverageRatio", Value.fromBigInt(BigInt.zero()));
    this.set("newLeverageRatio", Value.fromBigInt(BigInt.zero()));
    this.set("rebalanceNotional", Value.fromBigInt(BigInt.zero()));
    this.set("etherIncentive", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save RipcordCalled entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save RipcordCalled entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("RipcordCalled", id.toString(), this);
    }
  }

  static load(id: string): RipcordCalled | null {
    return changetype<RipcordCalled | null>(store.get("RipcordCalled", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get currentLeverageRatio(): BigInt {
    let value = this.get("currentLeverageRatio");
    return value!.toBigInt();
  }

  set currentLeverageRatio(value: BigInt) {
    this.set("currentLeverageRatio", Value.fromBigInt(value));
  }

  get newLeverageRatio(): BigInt {
    let value = this.get("newLeverageRatio");
    return value!.toBigInt();
  }

  set newLeverageRatio(value: BigInt) {
    this.set("newLeverageRatio", Value.fromBigInt(value));
  }

  get rebalanceNotional(): BigInt {
    let value = this.get("rebalanceNotional");
    return value!.toBigInt();
  }

  set rebalanceNotional(value: BigInt) {
    this.set("rebalanceNotional", Value.fromBigInt(value));
  }

  get etherIncentive(): BigInt {
    let value = this.get("etherIncentive");
    return value!.toBigInt();
  }

  set etherIncentive(value: BigInt) {
    this.set("etherIncentive", Value.fromBigInt(value));
  }
}

export class StreamingFee extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("timestamp", Value.fromBigInt(BigInt.zero()));
    this.set("setToken", Value.fromString(""));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save StreamingFee entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save StreamingFee entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("StreamingFee", id.toString(), this);
    }
  }

  static load(id: string): StreamingFee | null {
    return changetype<StreamingFee | null>(store.get("StreamingFee", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get setToken(): string {
    let value = this.get("setToken");
    return value!.toString();
  }

  set setToken(value: string) {
    this.set("setToken", Value.fromString(value));
  }

  get managerFee(): BigInt | null {
    let value = this.get("managerFee");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set managerFee(value: BigInt | null) {
    if (!value) {
      this.unset("managerFee");
    } else {
      this.set("managerFee", Value.fromBigInt(<BigInt>value));
    }
  }

  get protocolFee(): BigInt | null {
    let value = this.get("protocolFee");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set protocolFee(value: BigInt | null) {
    if (!value) {
      this.unset("protocolFee");
    } else {
      this.set("protocolFee", Value.fromBigInt(<BigInt>value));
    }
  }

  get newStreamingFee(): BigInt | null {
    let value = this.get("newStreamingFee");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set newStreamingFee(value: BigInt | null) {
    if (!value) {
      this.unset("newStreamingFee");
    } else {
      this.set("newStreamingFee", Value.fromBigInt(<BigInt>value));
    }
  }

  get newFeeRecipient(): Bytes | null {
    let value = this.get("newFeeRecipient");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set newFeeRecipient(value: Bytes | null) {
    if (!value) {
      this.unset("newFeeRecipient");
    } else {
      this.set("newFeeRecipient", Value.fromBytes(<Bytes>value));
    }
  }
}

export class SimpleIndexTokenIssuance extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("buyerAddress", Value.fromBytes(Bytes.empty()));
    this.set("SimpleIndexToken", Value.fromString(""));
    this.set("quantity", Value.fromBigInt(BigInt.zero()));
    this.set("issuer", Value.fromString(""));
    this.set("transaction", Value.fromString(""));
    this.set("fee", Value.fromString(""));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save SimpleIndexTokenIssuance entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save SimpleIndexTokenIssuance entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("SimpleIndexTokenIssuance", id.toString(), this);
    }
  }

  static load(id: string): SimpleIndexTokenIssuance | null {
    return changetype<SimpleIndexTokenIssuance | null>(
      store.get("SimpleIndexTokenIssuance", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get buyerAddress(): Bytes {
    let value = this.get("buyerAddress");
    return value!.toBytes();
  }

  set buyerAddress(value: Bytes) {
    this.set("buyerAddress", Value.fromBytes(value));
  }

  get SimpleIndexToken(): string {
    let value = this.get("SimpleIndexToken");
    return value!.toString();
  }

  set SimpleIndexToken(value: string) {
    this.set("SimpleIndexToken", Value.fromString(value));
  }

  get quantity(): BigInt {
    let value = this.get("quantity");
    return value!.toBigInt();
  }

  set quantity(value: BigInt) {
    this.set("quantity", Value.fromBigInt(value));
  }

  get issuer(): string {
    let value = this.get("issuer");
    return value!.toString();
  }

  set issuer(value: string) {
    this.set("issuer", Value.fromString(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    return value!.toString();
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }

  get fee(): string {
    let value = this.get("fee");
    return value!.toString();
  }

  set fee(value: string) {
    this.set("fee", Value.fromString(value));
  }
}

export class SimpleIndexToken extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("address", Value.fromBytes(Bytes.empty()));
    this.set("name", Value.fromString(""));
    this.set("manager", Value.fromString(""));
    this.set("totalSupply", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save SimpleIndexToken entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save SimpleIndexToken entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("SimpleIndexToken", id.toString(), this);
    }
  }

  static load(id: string): SimpleIndexToken | null {
    return changetype<SimpleIndexToken | null>(
      store.get("SimpleIndexToken", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get address(): Bytes {
    let value = this.get("address");
    return value!.toBytes();
  }

  set address(value: Bytes) {
    this.set("address", Value.fromBytes(value));
  }

  get name(): string {
    let value = this.get("name");
    return value!.toString();
  }

  set name(value: string) {
    this.set("name", Value.fromString(value));
  }

  get manager(): string {
    let value = this.get("manager");
    return value!.toString();
  }

  set manager(value: string) {
    this.set("manager", Value.fromString(value));
  }

  get issuances(): Array<string> {
    let value = this.get("issuances");
    return value!.toStringArray();
  }

  set issuances(value: Array<string>) {
    this.set("issuances", Value.fromStringArray(value));
  }

  get totalSupply(): BigInt {
    let value = this.get("totalSupply");
    return value!.toBigInt();
  }

  set totalSupply(value: BigInt) {
    this.set("totalSupply", Value.fromBigInt(value));
  }
}

export class SimpleIndexTokenRedeemed extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("SimpleIndexToken", Value.fromBytes(Bytes.empty()));
    this.set("redeemer", Value.fromBytes(Bytes.empty()));
    this.set("to", Value.fromBytes(Bytes.empty()));
    this.set("transaction", Value.fromString(""));
    this.set("quantity", Value.fromBigInt(BigInt.zero()));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save SimpleIndexTokenRedeemed entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save SimpleIndexTokenRedeemed entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("SimpleIndexTokenRedeemed", id.toString(), this);
    }
  }

  static load(id: string): SimpleIndexTokenRedeemed | null {
    return changetype<SimpleIndexTokenRedeemed | null>(
      store.get("SimpleIndexTokenRedeemed", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get SimpleIndexToken(): Bytes {
    let value = this.get("SimpleIndexToken");
    return value!.toBytes();
  }

  set SimpleIndexToken(value: Bytes) {
    this.set("SimpleIndexToken", Value.fromBytes(value));
  }

  get redeemer(): Bytes {
    let value = this.get("redeemer");
    return value!.toBytes();
  }

  set redeemer(value: Bytes) {
    this.set("redeemer", Value.fromBytes(value));
  }

  get to(): Bytes {
    let value = this.get("to");
    return value!.toBytes();
  }

  set to(value: Bytes) {
    this.set("to", Value.fromBytes(value));
  }

  get transaction(): string {
    let value = this.get("transaction");
    return value!.toString();
  }

  set transaction(value: string) {
    this.set("transaction", Value.fromString(value));
  }

  get quantity(): BigInt {
    let value = this.get("quantity");
    return value!.toBigInt();
  }

  set quantity(value: BigInt) {
    this.set("quantity", Value.fromBigInt(value));
  }
}
